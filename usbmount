#!/bin/sh
# This script mounts USB mass storage devices when they are plugged in
# and unmounts them when they are removed.
# Copyright © 2004, 2005 Martin Dickopp
# Copyright © 2008-2012 Rogério Theodoro de Brito
#
# This file is free software; the copyright holder gives unlimited
# permission to copy and/or distribute it, with or without
# modifications, as long as this notice is preserved.
#
# This file is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.
#
set -e
exec > /dev/null 2>&1

######################################################################
# Variables definition

# Default values for variables define in the configuration file.
ENABLED=1
MOUNTPOINTS=
FILESYSTEMS=
MOUNTOPTIONS=
FS_MOUNTOPTIONS=
WHITELIST=
VERBOSE=no


######################################################################
# Internal functions

# Test if the first parameter is in the list given by the second
# parameter.
in_list()
{
	for v in $2; do
		[ "$1" != "$v" ] || return 0
	done
	return 1
}


######################################################################
# Main program

# Load shared functions
. /usr/share/usbmount/functions

if [ -r /etc/usbmount/usbmount.conf ]; then
	. /etc/usbmount/usbmount.conf
	log debug "loaded usbmount configurations"
fi

if [ "${ENABLED:-1}" -eq 0 ]; then
	log info "usbmount is disabled, see /etc/usbmount/usbmount.conf"
	exit 0
fi

# Export verbosity level to be usable from hooks
export VERBOSE="$VERBOSE"

# Per Policy 9.3.2, directories under /var/run have to be created
# after every reboot.
if [ ! -e /var/run/usbmount ]; then
	mkdir -p /var/run/usbmount
	log debug "creating /var/run/usbmount directory"
fi

umask 022


if [ "$1" = add ]; then

	# Acquire lock.
	log debug "trying to acquire lock /var/run/usbmount/.mount.lock"
	lockfile-create --retry 3 /var/run/usbmount/.mount || \
		log err "cannot acquire lock /var/run/usbmount/.mount.lock"
	trap '( lockfile-remove /var/run/usbmount/.mount )' 0
	log debug "acquired lock /var/run/usbmount/.mount.lock"

	# Query udev for the expected device information (as we are now running in
	# a service's context and the env variables have been lost)
	if udevadm info --query=name --name="$DEVNAME" > /dev/null 2>&1 ; then
		# Additional variables provided by udev are prefixed by "UDEV_"
		eval $( udevadm info --query=env --export --export-prefix="UDEV_" "$DEVNAME" )
		# udev converts some characters, including spaces, into hexadecimal. We
		# want them as is, so we use 'echo -e' to interpret them.
		label="$( /bin/echo -e $UDEV_ID_FS_LABEL_ENC )"
		# In /etc/fstab, since spaces are used to delimit fields, if a field
		# contains spaces, these spaces must be replaced by \040.
		label_fstab="$( echo $label | sed 's/ /\\\\040/g' )"
	else
		log err "Device $DEVNAME not found"
	fi

	if ! echo $UDEV_ID_FS_USAGE | egrep -q "(filesystem|disklabel)"; then
		log debug "$DEVNAME is a $UDEV_DEVTYPE"
		log info "$DEVNAME does not contain a filesystem or disklabel"
		exit 0
	else
		log debug "$DEVNAME contains filesystem type $UDEV_ID_FS_TYPE"
	fi

	# If there is a white list, check if the device is allowed to be mounted
	if [ -n "$WHITELIST" ]; then
		if in_list "$UDEV_ID_SERIAL" "$WHITELIST"; then
			log debug "$DEVNAME with serial id $UDEV_ID_SERIAL is allowed"
			allowed_device="yes"
		elif in_list "$UDEV_ID_SERIAL_SHORT" "$WHITELIST"; then
			log debug "$DEVNAME with serial id $UDEV_ID_SERIAL_SHORT is allowed"
			allowed_device="yes"
		fi
		if [ "$allowed_device" != "yes" ]; then
			log warning "$DEVNAME is not allowed to be mounted"
			exit 0
		fi
	fi

	# To mount the device, try using the specifications in /etc/fstab first,
	# otherwise use the default mount options.

	if egrep -q "^[[:blank:]]*$DEVNAME" /etc/fstab; then
		log debug "$DEVNAME is identified in the fstab by its device name"
		mount_command="mount --source $DEVNAME"

	elif grep -q "^[[:blank:]]*UUID=$UDEV_ID_FS_UUID" /etc/fstab; then
		log debug "$DEVNAME is identified in the fstab by its UUID"
		mount_command="mount --uuid $UDEV_ID_FS_UUID"

	elif grep -q "^[[:blank:]]*LABEL=$label_fstab" /etc/fstab; then
		log debug "$DEVNAME is identified in the fstab by its LABEL"
		mount_command="mount --label $label"

	else
		log debug "$DEVNAME is not identified in the fstab"
		# Test if the filesystem type is in the list of filesystem
		# types to mount.
		if in_list "$UDEV_ID_FS_TYPE" "$FILESYSTEMS"; then
			# Search an available mountpoint.
			if [ -z $MOUNTPOINTS ]; then
				# Default mountpoints
				n=0
				while [ $n -le 9 ]; do
					dirname="/media/usb$n"
					if [ -d "$dirname" ]; then
						# Check if the directory is used as mountpoint by a device
						mounted_device="$( findmnt --noheadings --output SOURCE --mountpoint "$dirname" || : )"
						if [ -z "$mounted_device" ]; then
							mountpoint="$dirname"
							log debug "mountpoint $mountpoint is available for $DEVNAME"
							break
						else
							log debug "mountpoint $dirname is used by $mounted_device"
						fi
					else
						# No directory available, so create it one
						log info "executing command: mkdir -m 755 $dirname"
						mkdir -m 755 "$dirname" ||
							log warning "create directory $dirname wasn't successful; return code $?"
						mountpoint="$dirname"
						log debug "mountpoint $mountpoint is available for $DEVNAME"
						break
					fi
					n=$(( n + 1 ))
				done
			else
				# From config file
				for v in $MOUNTPOINTS; do
					if [ -d "$v" ]; then
						mounted_device="$( findmnt --noheadings --output SOURCE --mountpoint "$v" || : )"
						if [ -z "$mounted_device" ]; then
							mountpoint="$v"
							log debug "mountpoint $mountpoint is available for $DEVNAME"
							break
						else
							log debug "mountpoint $v is used by $mounted_device"
						fi
					fi
				done
			fi

			if [ -n "$mountpoint" ]; then
				# Determine mount options.
				options=
				for v in $FS_MOUNTOPTIONS; do
					if expr "$v" : "-fstype=$UDEV_ID_FS_TYPE,."; then
						options="$(echo "$v" | sed 's/^[^,]*,//')"
						break
					fi
				done
				if [ -n "$MOUNTOPTIONS" ]; then
					options="$MOUNTOPTIONS${options:+,$options}"
				fi

				# Mount the filesystem.
				mount_command="mount --type $UDEV_ID_FS_TYPE ${options:+--options $options} --source $DEVNAME --target $mountpoint"

			else
				# No suitable mount point found.
				log err "no mountpoint found for $DEVNAME"
			fi
		fi
	fi

	# Run pre-mount hook scripts; ignore errors.
	export UM_DEVICE="$DEVNAME"
	export UM_MOUNTPOINT="$mountpoint"
	export UM_FILESYSTEM="$UDEV_ID_FS_TYPE"
	export UM_MOUNTOPTIONS="$options"
	export UM_VENDOR="$UDEV_ID_VENDOR"
	export UM_MODEL="$UDEV_ID_MODEL"
	log info "executing command: run-parts /etc/usbmount/pre-mount.d"
	run-parts /etc/usbmount/pre-mount.d || :

	# Mount the device
	log info "executing command: $mount_command"
	$mount_command || log err "mount device $DEVNAME wasn't successful; return code $?"

	# Run post-mount hook scripts if the mount was succesful; ignore errors.
	# If the mounting is done from the fstab, we do not know the mountpoint,
	# or the options. But we can get them from key/value pairs provided by
	# findmnt
	eval "$( findmnt --pairs --source "$DEVNAME" || : )"
	export UM_MOUNTPOINT="$TARGET"
	export UM_MOUNTOPTIONS="$OPTIONS"
	log info "executing command: run-parts /etc/usbmount/post-mount.d"
	run-parts /etc/usbmount/post-mount.d || :

elif [ "$1" = remove ]; then
	# A block or partition device has been removed.

	# Get key/value pairs provided by findmnt
	eval "$( findmnt --pairs --source "$DEVNAME" || : )"
	device="$SOURCE"
	mountpoint="$TARGET"
	fstype="$FSTYPE"

	if [ "$DEVNAME" = "$device" ] ; then
		# If the mountpoint and filesystem type are maintained by this
		# script, unmount the filesystem. This does not support devices
		# mounted from fstab.
		if [ -z $MOUNTPOINTS ]; then
			# Default mountpoints
			if expr "$mountpoint " : '/media/usb[0-9] ' ;then
				if in_list "$fstype" "$FILESYSTEMS"; then
					log debug "$DEVNAME contains filesystem type $fstype"
					log info "executing command: umount -l $mountpoint"
					umount -l "$mountpoint" || log err "$DEVNAME umount wasn't successful; return code $?"
				fi
			fi
		else
			# From config file
			if in_list "$mountpoint" "$MOUNTPOINTS" ;then
				if in_list "$fstype" "$FILESYSTEMS"; then
					log debug "$DEVNAME contains filesystem type $fstype"
					log info "executing command: umount -l $mountpoint"
					umount -l "$mountpoint" || log err "$DEVNAME umount wasn't successful; return code $?"
				fi
			fi
		fi
	else
		log info "Device $DEVNAME wasn't mounted"
	fi

	# Always run hook scripts; ignore errors.
	export UM_DEVICE="$DEVNAME"
	export UM_MOUNTPOINT="$mountpoint"
	export UM_FILESYSTEM="$fstype"
	log info "executing command: run-parts /etc/usbmount/umount.d"
	run-parts /etc/usbmount/umount.d || :
else
	log err "unexpected: action '$1'"
fi

log debug "usbmount execution finished"

# vim: noet
